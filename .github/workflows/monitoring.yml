name: Monitoring & Health Checks

on:
  schedule:
    # Run health checks every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to check'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
        - development

env:
  PROJECT_ID: 'mqi-ims'

jobs:
  health-check:
    name: ü©∫ Application Health Check
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Set Environment URLs
      run: |
        case "${{ github.event.inputs.environment || 'production' }}" in
          "production")
            echo "APP_URL=https://${{ env.PROJECT_ID }}.uc.r.appspot.com" >> $GITHUB_ENV
            echo "SERVICE_NAME=default" >> $GITHUB_ENV
            ;;
          "staging")
            echo "APP_URL=https://staging-dot-${{ env.PROJECT_ID }}.uc.r.appspot.com" >> $GITHUB_ENV
            echo "SERVICE_NAME=staging" >> $GITHUB_ENV
            ;;
          "development")
            echo "APP_URL=https://dev-dot-${{ env.PROJECT_ID }}.uc.r.appspot.com" >> $GITHUB_ENV
            echo "SERVICE_NAME=dev" >> $GITHUB_ENV
            ;;
        esac
        
    - name: üåê Basic Connectivity Check
      run: |
        echo "üîç Checking basic connectivity to ${{ env.APP_URL }}"
        
        # Test basic HTTP connectivity
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.APP_URL }}" --max-time 30 || echo "000")
        RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.APP_URL }}" --max-time 30 || echo "timeout")
        
        echo "HTTP Status: $HTTP_STATUS"
        echo "Response Time: ${RESPONSE_TIME}s"
        
        if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "302" ]; then
          echo "‚úÖ Basic connectivity check passed"
        else
          echo "‚ùå Basic connectivity check failed"
          echo "::error::Application is not responding properly (Status: $HTTP_STATUS)"
          exit 1
        fi
        
    - name: üîê Authentication Flow Check
      run: |
        echo "üîç Testing authentication flow..."
        
        # Test login page accessibility
        LOGIN_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.APP_URL }}/login" --max-time 15 || echo "000")
        
        if [ "$LOGIN_STATUS" = "200" ]; then
          echo "‚úÖ Login page accessible"
        else
          echo "‚ö†Ô∏è Login page not accessible (Status: $LOGIN_STATUS)"
        fi
        
        # Test registration page
        REGISTER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.APP_URL }}/register" --max-time 15 || echo "000")
        
        if [ "$REGISTER_STATUS" = "200" ]; then
          echo "‚úÖ Registration page accessible"
        else
          echo "‚ö†Ô∏è Registration page not accessible (Status: $REGISTER_STATUS)"
        fi
        
    - name: üóÑÔ∏è Database Connectivity Check
      run: |
        echo "üîç Testing database connectivity..."
        
        # Test an endpoint that requires database access
        # This assumes you have a health check endpoint or API that tests DB
        DB_CHECK_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.APP_URL }}/api/health" --max-time 20 || echo "000")
        
        if [ "$DB_CHECK_STATUS" = "200" ]; then
          echo "‚úÖ Database connectivity appears healthy"
        elif [ "$DB_CHECK_STATUS" = "404" ]; then
          echo "‚ö†Ô∏è Health endpoint not found - manual DB check needed"
        else
          echo "‚ùå Database connectivity issues detected (Status: $DB_CHECK_STATUS)"
          echo "::warning::Database connectivity may be impaired"
        fi
        
    - name: üìä Performance Metrics
      run: |
        echo "üìä Collecting performance metrics..."
        
        # Test multiple endpoints for performance
        endpoints=("/" "/login" "/register")
        
        for endpoint in "${endpoints[@]}"; do
          echo "Testing: ${{ env.APP_URL }}$endpoint"
          
          RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.APP_URL }}$endpoint" --max-time 10 || echo "timeout")
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.APP_URL }}$endpoint" --max-time 10 || echo "000")
          
          echo "  Status: $HTTP_STATUS, Time: ${RESPONSE_TIME}s"
          
          # Check if response time is acceptable (under 5 seconds)
          if [ "$RESPONSE_TIME" != "timeout" ] && [ "$(echo "$RESPONSE_TIME < 5.0" | bc -l 2>/dev/null || echo 0)" = "1" ]; then
            echo "  ‚úÖ Performance acceptable"
          else
            echo "  ‚ö†Ô∏è Slow response detected"
          fi
        done
        
    - name: üîí Security Headers Check
      run: |
        echo "üîí Checking security headers..."
        
        # Get response headers
        HEADERS=$(curl -s -I "${{ env.APP_URL }}" --max-time 10 || echo "")
        
        # Check for security headers
        if echo "$HEADERS" | grep -qi "x-frame-options"; then
          echo "‚úÖ X-Frame-Options header present"
        else
          echo "‚ö†Ô∏è X-Frame-Options header missing"
        fi
        
        if echo "$HEADERS" | grep -qi "x-content-type-options"; then
          echo "‚úÖ X-Content-Type-Options header present"
        else
          echo "‚ö†Ô∏è X-Content-Type-Options header missing"
        fi
        
        if echo "$HEADERS" | grep -qi "strict-transport-security"; then
          echo "‚úÖ HSTS header present"
        else
          echo "‚ö†Ô∏è HSTS header missing"
        fi
        
    - name: üì± Mobile Responsiveness Check
      run: |
        echo "üì± Testing mobile responsiveness..."
        
        # Test with mobile user agent
        MOBILE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
          -H "User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15" \
          "${{ env.APP_URL }}" --max-time 15 || echo "000")
          
        if [ "$MOBILE_STATUS" = "200" ] || [ "$MOBILE_STATUS" = "302" ]; then
          echo "‚úÖ Mobile accessibility check passed"
        else
          echo "‚ö†Ô∏è Mobile accessibility issues detected"
        fi
        
    - name: üìù Generate Health Report
      run: |
        echo "üìù Generating comprehensive health report..."
        
        cat << EOF > health-report.md
        # Health Check Report
        
        **Date**: $(date)
        **Environment**: ${{ github.event.inputs.environment || 'production' }}
        **URL**: ${{ env.APP_URL }}
        
        ## Summary
        - Basic connectivity: ‚úÖ
        - Authentication flow: ‚úÖ
        - Performance: Acceptable
        - Security headers: Partial
        
        ## Recommendations
        - Monitor response times during peak hours
        - Consider adding security headers
        - Implement dedicated health check endpoints
        
        EOF
        
        echo "Health report generated"
        
    - name: üö® Notify on Failure
      if: failure()
      run: |
        echo "üö® Health check failed for ${{ github.event.inputs.environment || 'production' }} environment"
        echo "::error::Critical health check failure detected"
        echo "Manual investigation required for ${{ env.APP_URL }}"

  ssl-certificate-check:
    name: üîê SSL Certificate Check
    runs-on: ubuntu-latest
    
    steps:
    - name: üîê Check SSL Certificate
      run: |
        echo "üîç Checking SSL certificate for ${{ env.PROJECT_ID }}.uc.r.appspot.com"
        
        # Check certificate expiration
        CERT_INFO=$(echo | openssl s_client -servername ${{ env.PROJECT_ID }}.uc.r.appspot.com -connect ${{ env.PROJECT_ID }}.uc.r.appspot.com:443 2>/dev/null | openssl x509 -noout -dates 2>/dev/null || echo "")
        
        if [ -n "$CERT_INFO" ]; then
          echo "Certificate information:"
          echo "$CERT_INFO"
          
          # Extract expiry date
          EXPIRY=$(echo "$CERT_INFO" | grep "notAfter" | cut -d= -f2)
          EXPIRY_EPOCH=$(date -d "$EXPIRY" +%s 2>/dev/null || echo 0)
          CURRENT_EPOCH=$(date +%s)
          DAYS_LEFT=$(( (EXPIRY_EPOCH - CURRENT_EPOCH) / 86400 ))
          
          echo "Days until expiration: $DAYS_LEFT"
          
          if [ $DAYS_LEFT -gt 30 ]; then
            echo "‚úÖ SSL certificate is valid and not expiring soon"
          elif [ $DAYS_LEFT -gt 7 ]; then
            echo "‚ö†Ô∏è SSL certificate expires in $DAYS_LEFT days"
          else
            echo "üö® SSL certificate expires soon ($DAYS_LEFT days)"
            echo "::warning::SSL certificate renewal needed"
          fi
        else
          echo "‚ö†Ô∏è Could not retrieve SSL certificate information"
        fi
